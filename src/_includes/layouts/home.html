{%- extends "layouts/base.html" -%}

{%- block content -%}
  {%- include "partials/hero-section.html" -%}
  {%- include "partials/product-section.html" -%}
  {% include "partials/product-gallery.html" %}
  <div class="about-contact-container grid">
    {%- include "partials/about-section.html" -%}
    {%- include "partials/contact-section.html" -%}
  </div>
  {{ content | safe }}
{%- endblock -%}

{%- block bodyScripts -%}
  <script>
    (function () {
      if (!'IntersectionObserver' in window) {
        return;
      }
      const elements = document.querySelectorAll('.fade-in');

      let observer = new IntersectionObserver(
        (changes, observer) => {
          let timeout = 0;

          changes.forEach(change => {
            if (change.intersectionRatio > 0) {
              timeout += 100;
              setTimeout(() => {
                change.target.setAttribute('data-state', 'visible');
              }, timeout);
            }
          });
        },
        {
          root: null,
          rootMargin: '0px',
          threshold: 0
        }
      );

      elements.forEach(element => {
        element.setAttribute('data-state', 'hidden');

        observer.observe(element);
      });
    })();
  </script>
  
  <script>
    // https://pqina.nl/blog/applying-styles-based-on-the-user-scroll-position-with-smart-css/

    // The debounce function receives our function as a parameter
    const debounce = (fn) => {

      // This holds the requestAnimationFrame reference, so we can cancel it if we wish
      let frame;

      // The debounce function returns a new function that can receive a variable number of arguments
      return (...params) => {
        
        // If the frame variable has been defined, clear it now, and queue for next frame
        if (frame) { 
          cancelAnimationFrame(frame);
        }

        // Queue our function call for the next frame
        frame = requestAnimationFrame(() => {
          
          // Call our function and pass any params we received
          fn(...params);
        });

      } 
    };

    //define inquiry element
    const inquiryElement = document.querySelector(".inquiry");

    const toggleInquiry = () => {
      if (window.scrollY > 32) {
        inquiryElement.toggleAttribute("data-sticky", "true");
      }
    }

    // Listen for new scroll events, here we debounce our `toggleInquiry` function
    document.addEventListener('scroll', debounce(toggleInquiry), { passive: true });

    // Update scroll position for first time
    toggleInquiry();
  </script>
  
  {# <script>
    const header = document.querySelector(".site-head");
    const intercept = document.querySelector(".skip-to-main");

    const observer = new IntersectionObserver(([entry]) => {
      header.toggleAttribute("data-sticky", !entry.isIntersecting);
    });

    observer.observe(intercept);
  </script> #}

  {# <script src="/scripts/details-utils.js" defer async></script> #}
  <script src="/scripts/toggle-disclosure.js" defer async></script>
  {# <script src="/scripts/set-height.js" defer async></script> #}

{%- endblock -%}
